==============================
uniform initialization (C++11)
==============================
uses curly braces {}, compiler will give 'narrowing conversion' error for something like this
int x {7.7};
So this prevents unforeseen value truncation
This is better than initialization using parantheses () because the compiler can only give a warning for something like this
int x (7.7);

===============
nullptr (C++11)
===============
guaranteed to be compatible with any pointer type, better than NULL macro which is interpreted differently based on compiler

=============================
std::chrono (C++11)
std::chrono::literals (C++14)
=============================

===================================
auto [variable] (C++11)
auto [function return type] (C++14)
===================================
sometimes the programmer cannot know the type because it will be generated by the compiler, so auto is the only way to declare the variable
auto will only give the underlying type, if we want the const qualifier we must explicitly add it ourselves

============================
range-based for loop (C++11)
============================
for (auto it : v) std::cout << it << ", ";
must explicitly add the & qualifier if we want to modify the value pointed to by the iterator

==============
lambda (C++11)
==============
anonymous functions defined inline
[ captures ] ( params ) specs requires(optional) { body }
[=] capture all local variables by value
[&] capture all local variables by reference
[this] captures reference to the deferenced 'this' pointer of the object
very useful when passed as callable object to stl algorithms

==============
lambda (C++14)
==============
default parameters
template parameters
generalised capture
returning a lambda from a function (thanks to ability to return auto from a function)

==============
lambda (C++17)
==============
can be declared constexpr so then evaluation can happen at compile time

==============
lambda (C++20)
==============
classic syntax to define templates
capture a variadic pack of parameters

=================
std::move (C++11)
=================
an lvalue can have its address taken using the & operator, while an rvalue cannot
a reference is really a disguised pointer, the object must have an address so it is an "lvalue reference" &
data can only be moved into a function call argument if it is an "rvalue reference" &&
std::move does not move data, it just casts its argument to an "rvalue reference", but the function that recieves the rvalue now has ownership of the object referenced
and we now have a move constructor and a move assignment operator

================
noexcept (C++11)
================
function promises it will not throw an exception

================
= delete (C++11)
================
instead of making special member functions private to prevent their use, we can now simply delete them

=================
= default (C++11)
=================
ask the compiler to generate a default version of a special member function

==============
random (C++11)
==============
typedef mersenne_twister_engine<uint_fast32_t,32,624,397,31,0x9908b0df,11,0xffffffff,7,0x9d2c5680,15,0xefc60000,18,1812433253> mt19937;
std::uniform_int_distribution is just one of many distributions

===========
concurrency
===========
illusion of concurrency when the OS does task switching for the one cpu (core)
hardware concurrency when there are all multiple cores (hardware threads)
software threads each get a slice of time

===================
rise of concurrency
===================
Internet Servers getting more traffic
Windows Users wanting to run multiple programs
Games/Multimedia
More cores

==========================
concurrency vs parallelism
==========================
concurrency = different tasks running at the same time
parallelism = same tasks running at the same time

==================
(software) threads
==================
threads are lightweight processes
separation of concerns - each concern gets its own thread
if the threads can take advantage of multiple cores, then the software threads become hardware threads

===========================
concurrency and shared data
===========================
1. Traditional threaded programming using locks to restrict access [focus of this course]
2. Lock-free programming using atomic variables
3. Functional programming (scala) avoids shared data

======================
old school concurrency
======================
Spawn a new process using fork() on Unix, this is faster than comparable method on Windows
fork() returns in both parent (with child id) and in child (with 0) processes

===================
std::thread (C++11)
===================
fairly low-level, but efficient, implementation of threads compared to other languages
(a task is a higher-level concept to describe a bit of work that needs to be done concurrently)
1. thread-safe standard library
2. memory model and atomic operations
3. features to create and manage threads added to standard library
Cannot be copied but can be moved, as is with all classes that manage OS resources (e.g., files)

===================
std::thread (C++14)
===================
read-write locks

===================
std::thread (C++17)
===================
parallelized versions of many standard algorithms (if supported by hardware)

===================
std::thread (C++20)
===================
coroutines
joining threads
improved synchronization facilities










































